---
description: KinOS Solar CRM project rules and context
globs:
alwaysApply: true
---

# KinOS â€” Solar CRM for KIN Home

## What This Project Is
KinOS is an internal CRM replacing Enerflo for KIN Home's solar sales operations.
Built with Next.js 16 (App Router), Supabase (Postgres + Auth + RLS), deployed on Vercel.
Epics 0â€“9 are complete (Auth, RepCard, Pipeline, Leads, Calendar, Aurora Design, Proposal/Pricing, Financing, Document Signing + Notifications). Epic 10 (Submission & Gating) is next.

## Before You Start ANY Task
Read these docs before making changes â€” not just for "architectural decisions", but for ANY non-trivial work.
The goal: every agent understands what exists, what we're building toward, and how current work fits in.

**Understand the vision and future:**
- `/docs/kinos-vision-and-state.md` â€” What we're building, why, current state, architecture decisions, what's next
- `/docs/kinos-future-features.md` â€” Detailed explainers for ALL planned features with build constraints. READ BEFORE BUILDING.

**Understand what exists today:**
- `/docs/PROJECT-KNOWLEDGE.md` â€” Master knowledge base: schema, migrations, API routes, epic status. **Single source of truth.**
- `/docs/db-audit.md` â€” Live database inventory with column summaries (51 tables + 2 views, verified 2026-02-12)
- `/docs/schema-reference.md` â€” Column-level schema from live DB (51 tables, 952 columns)

**Architecture reference:**
- `/docs/blueprint.md` â€” Full system architecture spec (reference, may lag behind actual state)

## Tech Stack
- **Framework:** Next.js 16 with App Router (NOT Pages Router). Middleware file is `proxy.ts` not `middleware.ts`.
- **Database:** Supabase (Postgres) with Row Level Security. 51 tables + 2 views live.
- **Auth:** Supabase Auth (email/password). No self-registration. Admin creates accounts.
- **Styling:** Tailwind CSS + shadcn/ui components
- **Language:** TypeScript (strict mode)
- **Package Manager:** pnpm
- **Deployment:** Vercel at kin-os-one.vercel.app (auto-deploys from main branch)

## Database Access Patterns
- **Browser/Client components:** Use `lib/supabase/client.ts` (anon key, respects RLS)
- **Server components/actions:** Use `lib/supabase/server.ts` (cookie-based auth, respects RLS)
- **Webhooks/API routes:** Use `lib/supabase/admin.ts` (service role, bypasses RLS)
- NEVER use the service role client in client components
- NEVER expose the service role key to the browser

## Pipeline Stages (19 stages â€” blueprint Â§9)
```
new_lead â†’ appointment_set â†’ appointment_sat â†’ design_requested â†’
design_complete â†’ proposal_sent â†’ proposal_accepted â†’ financing_applied â†’
financing_approved â†’ stips_pending â†’ stips_cleared â†’ contract_sent â†’
contract_signed â†’ submission_ready â†’ submitted â†’ intake_approved
                                                â†’ intake_rejected
Also: cancelled, lost
```
Stage constants are in `lib/constants/pipeline.ts`. Do NOT add, remove, or rename stages without explicit instruction.

Terminal stages: intake_approved, cancelled, lost
Revivable: lost â†’ appointment_set
Backward allowed: design_complete/proposal_sent â†’ design_requested (redesign)

KinOS pipeline ENDS at intake_approved. Everything after (install, permitting, inspection, PTO) lives in Quickbase.

## Key Tables (column counts from live DB â€” verify against `docs/schema-reference.md`)
- **deals** (93 cols) â€” core deal record with stage, pricing, system details, Aurora IDs
- **contacts** (44 cols) â€” customer info with utility/consumption fields, RepCard sync
- **proposals** (72 cols) â€” full pricing waterfall with design snapshot
- **users** (34 cols) â€” reps with RepCard sync, permission overrides
- **appointments** (24 cols) â€” RepCard appointment tracking with status/outcome
- **lender_products** (28 cols) â€” lender terms, rates, fee structure
- **v_deal_detail** (94+ cols) â€” denormalized view joining deal + contact + users + office + team + lender
- **v_deal_pipeline** (20 cols) â€” compact view for kanban/list display

## Existing API Routes
- `/api/deals` â€” Deals CRUD + search
- `/api/deals/[id]/notes` â€” Deal notes
- `/api/deals/transition` â€” Stage transitions
- `/api/contacts` â€” Contacts CRUD
- `/api/contacts/[id]` â€” Contact detail + assign
- `/api/appointments` â€” Appointments CRUD + cancel
- `/api/attachments` â€” Attachments CRUD
- `/api/notes` â€” Notes CRUD
- `/api/filter-presets` â€” Filter presets CRUD
- `/api/notifications` â€” Notifications GET (list) + PATCH (mark read)
- `/api/deals/[id]/documents` â€” Document envelopes GET + POST + PATCH
- `/api/webhooks/repcard/*` â€” 7 RepCard webhook routes (appointment-set, appointment-update, appointment-outcome, closer-update, status-changed, contact-type-changed, door-knocked)

## Existing Pages
- `/` â€” Dashboard
- `/deals` â€” Kanban + list pipeline views
- `/deals/[id]` â€” Deal detail with workflow stepper
- `/leads` â€” Lead management
- `/leads/[id]` â€” Lead detail
- `/calendar` â€” Calendar (day/week/month/list)
- `/reports` â€” Reports
- `/design-requests` â€” Design queue
- `/admin/*` â€” Admin panels
- `/login` â€” Auth

## Key Architecture Rules
- All data is company-isolated via RLS policies using `company_id`
- Soft deletes everywhere (`deleted_at` column, never hard delete)
- Major tables have `created_at`, `updated_at`, `updated_by`
- Deal stage transitions auto-logged by Postgres trigger to `deal_stage_history`
- Contact field changes auto-logged by Postgres trigger to `contact_change_history`
- Deal closer/setter changes auto-logged to `deal_assignment_history`
- Deal numbers auto-generate as `KIN-{YEAR}-{SEQ}` via Postgres trigger

## Code Conventions
- API routes go in `app/api/` â€” webhooks, CRUD endpoints
- Use server components by default, `"use client"` only when needed
- Error handling: always try/catch Supabase calls, return typed results
- No `any` types â€” use generated Supabase types from `lib/supabase/database.types.ts`
- Webhook handlers: always use `supabaseAdmin`, log to `webhook_events`, return 200 quickly

## Integrations Status
- **RepCard:** âœ… Complete â€” 7 webhook handlers, user sync, contact creation
- **Aurora Solar:** âœ… Complete â€” API client, service layer, webhooks, 3 design paths
- **Lender APIs:** ðŸ“‹ Planned â€” 6 lenders with API access
- **Arrivy:** ðŸ“‹ Planned â€” Site survey scheduling + field management
- **Document Signing:** âœ… Manual tracking complete â€” ManualSigningProvider, PandaDoc adapter interface ready
- **Quickbase:** ðŸ“‹ Planned â€” Submission + post-sale sync
- **Sequifi/CaptiveIQ:** ðŸ“‹ Planned â€” Commission push
- **Twilio:** ðŸ“‹ Planned â€” Notifications

## Aurora Solar Integration (Epic 6 â€” Complete)
- Base URL: `https://api.aurorasolar.com`
- Auth: Bearer token + `X-Aurora-Api-Version: 2024.05`
- Tenant ID: `034b1c47-310a-460f-9d5d-b625dd354f12`
- Aurora webhooks are GET requests with data in URL query params (NOT POST with JSON)
- Key fields on deals: aurora_project_id, aurora_design_id, aurora_design_request_id, aurora_proposal_id, aurora_sales_mode_url, design_status, system_size_kw, annual_production_kwh, offset_percentage, panel_count, panel_model, inverter_model

## Schema Drift Warning (Users table)
The live users table differs from blueprint. Missing fields that will be needed later:
kin_id, job_title, sequifi_id, captiveiq_id, quickbase_record_id, repcard_username
Do NOT add these unless explicitly asked â€” they're tracked for a future migration.

## Future-Aware Development
Before building any feature, check `docs/kinos-future-features.md` for constraints that affect your implementation. Current code must support:
- Adapter pattern for all external integrations
- Notification events on deal state changes
- Audit trails on admin-configurable values
- RLS policies on every new table
- Responsive layouts (no desktop-only patterns)

Post-sale pipeline visibility, pricing engine admin, Arrivy site survey integration, and change order management are all planned. Don't build patterns that block these.

---

## POST-IMPLEMENTATION: Keep Everything In Sync

After completing ANY task that changes the system, you MUST update ALL affected files before committing.
Multiple files contain overlapping information. If you change something, update it EVERYWHERE it appears.

### Update Matrix

| What changed | Files to update |
|---|---|
| **New/modified table or column** | `docs/schema-reference.md`, `docs/db-audit.md`, `docs/PROJECT-KNOWLEDGE.md` Â§3, table counts in `CLAUDE.md` + `.cursor/rules/kinos.mdc` (Tech Stack + Key Tables) |
| **New migration** | `docs/PROJECT-KNOWLEDGE.md` Â§3 migration list |
| **New API route or webhook** | `docs/PROJECT-KNOWLEDGE.md` Â§4, `.cursor/rules/kinos.mdc` Existing API Routes |
| **New page or UI route** | `docs/PROJECT-KNOWLEDGE.md` Â§4, `.cursor/rules/kinos.mdc` Existing Pages |
| **New/changed integration** | `CLAUDE.md` Integrations Status, `.cursor/rules/kinos.mdc` Integrations Status, `docs/PROJECT-KNOWLEDGE.md` Â§1, `docs/blueprint.md` relevant section |
| **Epic completed** | `CLAUDE.md` epic status line, `.cursor/rules/kinos.mdc` epic status line, `docs/PROJECT-KNOWLEDGE.md` Â§9 |
| **Architecture decision** | `docs/PROJECT-KNOWLEDGE.md` Â§10, `docs/blueprint.md`, `docs/kinos-vision-and-state.md` if strategic |
| **Pipeline stages changed** | `CLAUDE.md` Pipeline Stages, `.cursor/rules/kinos.mdc` Pipeline Stages, `docs/PROJECT-KNOWLEDGE.md` Â§4, `docs/blueprint.md` Â§9 |

### Update As You Go â€” Not At The End
Do NOT batch doc updates for the end of a task. Update docs **immediately after each change** â€” after each migration, each new route, each new page. If you write a migration then move on to building the UI, update the schema docs BEFORE starting the UI work.

Why: context windows run out. If you save doc updates for last, they never happen, and the next agent starts with stale information. Treat doc updates as part of the implementation step, not a separate cleanup phase.

If you are running low on context and cannot finish the full task, **prioritize doc updates for work already completed** over starting new code. Incomplete code can be continued by the next agent â€” but only if the docs reflect what was actually built.

### Rules
- Update `Last updated` dates on any doc you touch
- Commit doc updates in the SAME commit as the code changes (or immediately after if the change is already committed)
- If you're unsure whether a file needs updating, read it and check
- The goal: the NEXT agent that reads these files gets accurate information
